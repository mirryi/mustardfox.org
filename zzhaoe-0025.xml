<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>801</fr:anchor><fr:addr
type="user">zzhaoe-0025</fr:addr><fr:route>zzhaoe-0025.xml</fr:route><fr:title
text="Cabal-foreign-library">Cabal-foreign-library</fr:title><fr:taxon>Software</fr:taxon><fr:date><fr:year>2024</fr:year></fr:date><fr:authors><fr:author><fr:link
type="local"
href="ericczhao.xml"
addr="ericczhao"
title="Eric Zhao">Eric Zhao</fr:link></fr:author></fr:authors><fr:meta
name="github">mirryi/cabal-foreign-library</fr:meta><fr:meta
name="crate">cabal-foreign-library</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>A library for Cargo build scripts to build and link a Cabal foreign library to Rust crates. The crate calls out to Cabal and GHC; all necesssary Haskell dependencies must be installed and managed separately.</fr:p></fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Backlinks">Backlinks</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>803</fr:anchor><fr:addr
type="user">zzhaoe-0023</fr:addr><fr:route>zzhaoe-0023.xml</fr:route><fr:title
text="Calling Haskell from Rust">Calling Haskell from Rust</fr:title><fr:taxon>Musings</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="ericczhao.xml"
addr="ericczhao"
title="Eric Zhao">Eric Zhao</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Everyone loves some good FFI. For Rust, we've seen plenty of Rust <fr:code>↔</fr:code> C, Rust <fr:code>↔</fr:code> C++, <fr:link
type="external"
href="https://crates.io/crates/pyo3">Rust <fr:code>↔</fr:code> Python</fr:link>, and even <fr:link
type="external"
href="https://crates.io/crates/cargo-cabal">Rust <fr:code>→</fr:code> Haskell</fr:link>, but there seems to be precious little on calling Haskell code <fr:em>from</fr:em> Rust. Whilst <fr:link
type="external"
href="https://crates.io/crates/cargo-cabal"><fr:code>cargo-cabal</fr:code></fr:link> turns a Rust crate into a Cabal library (automatically), I'd like to turn a Cabal library into a Rust crate (automatically).</fr:p><fr:p>This probably seems like an odd thing to do, but evidently <fr:link
type="external"
href="https://github.com/zotero/citeproc-rs/blob/master/pandoc-ffi-bridge/build-waat.rs">some</fr:link> have desired such things before. In my case, I'd like to call the <fr:link
type="external"
href="https://github.com/jrclogic/SMCDEL">SMCDEL model checker</fr:link> as part of a Rust compiler plugin.<html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="sidenote-number"><html:span
class="sidenote">For <fr:link
type="local"
href="zzhaoe-0024.xml"
addr="zzhaoe-0024"
title="Hermit">another project</fr:link>.</html:span></html:span></fr:p><fr:p>Ideally, some tool should make this as streamlined as possible.</fr:p><fr:ul><fr:li>I don't want to write raw C wrappers.</fr:li>
  <fr:li>I want Rust bindings for free.</fr:li>
  <fr:li><fr:code>cargo {build, test, etc.}</fr:code> just works.</fr:li></fr:ul><fr:p>Luckily, most of the pieces already exist. <fr:link
type="local"
href="zzhaoe-0025.xml"
addr="zzhaoe-0025"
title="Cabal-foreign-library"><fr:code>cabal-foreign-library</fr:code></fr:link> puts them together in a library for build scripts (à la <fr:link
type="external"
href="https://crates.io/crates/cc"><fr:code>cc</fr:code></fr:link>). I've written a small example <fr:link
type="external"
href="https://github.com/mirryi/cabal-foreign-library/tree/master/crates/example-foo">here</fr:link>.</fr:p><fr:p>The tool works for <fr:link
type="external"
href="https://cabal.readthedocs.io/en/3.10/cabal-package.html#foreign-libraries"><fr:code>foreign-libraries</fr:code></fr:link>. It calls out to <fr:code>cabal</fr:code> to build the shared dynamic library, and some functions are provided to auto-generate Rust bindings via <fr:link
type="external"
href="https://crates.io/crates/bindgen"><fr:code>bindgen</fr:code></fr:link> (GHC already generates C headers for us) and link the Rust crate to the shared library and necessary Haskell runtime libraries. Cabal, GHC, and any other Haskell dependency has to be installed and managed separately.</fr:p><fr:p><fr:code>cargo build</fr:code> just works, and <fr:code>cargo test</fr:code> works if we modify the <fr:code>rpath</fr:code> of the Rust executables. This option can be <fr:link
type="external"
href="https://docs.rs/cabal-foreign-library/0.2.0/cabal_foreign_library/struct.Lib.html#method.link">enabled</fr:link><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="sidenote-number"><html:span
class="sidenote"><fr:link
type="external"
href="https://github.com/mirryi/cabal-foreign-library/blob/5841b60b2b10fc44796fca3828049a256acab2ee/examples/basic/build.rs#L23">Here</fr:link> in the basic example. The same applies for <fr:link
type="external"
href="https://docs.rs/cabal-foreign-library/0.2.0/cabal_foreign_library/struct.Lib.html#method.link_system"><fr:code>Lib::link_system</fr:code></fr:link>.</html:span></html:span>
 in the build script.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>